# 프로세스 주소 공간 & 프로세스 간 통신 (IPC)

## 프로세스 주소 공간(Process Address Space)

- 프로세스 주소 공간은 일반적으로 코드, 데이터, 스택으로 나뉨
- 각각 프로그램 소스 코드 저장, 전역 변수 저장, 함수,지역 변수 저장의 역할을 함
- 이런식으로 최대한 데이터를 공유하여 메모리 사용량을 줄일 수 있음
  
![img](images_gang_shik_post_788ef0a0-24db-40b4-9181-471dc6062a1c_image.png)

### 코드 (텍스트) 영역

- 실행할 프로그램의 명령어 코드, 제어문, 상수 등이 저장됨
- 코드영역은 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 함수, 제어문, 상수 등이 지정됨
- 컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 Read-Only로 지정됨

### 데이터 영역

- 전역변수, static 변수가 저장되는 영역.
- 구체적으로는 GVAR 영역과 BSS 영역으로 나뉨.
- 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸함
- 실행 중도에 전역변수가 변경 될 수도 있으니, 이 영역은 Read-Write로 지정됨

> GVAR (Global Variable): 초기값이 있는 전역변수가 저장되는 영역  
> BSS (Block Started By Symbol): 초기값이 없는 전역변수가 저장되는 영역  

### 힙 영역

- 런타임에 크기가 결정되는 메모리 영역임
- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨
- 참조형의 데이터의 값이 저장됨
- Heap은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됨
- 객체와 같은 레퍼런스 타입의 데이터가 힙 영역에 저장됨
- 같은 프로세스의 쓰레드들은 힙 영역의 데이터를 공유함
- 대부분의 언어에서는 힙 영역에 할당된 자원의 해제를 가비지 컬렉터가 담당함
- 반면 C, C++ 에서는 프로그래머가 직접 free 해주어야 함
- 힙 영역에 저장된 데이터의 주소값 자체는 스택 영역에 저장됨
- Heap과 Stack은 같은 공간을 공유함, Heap이 메모리 위쪽 주소부터 할당되면 Stack은 아래쪽부터 할당되는 식임, 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 Heap Overflow, Stack Overflow라고 함

### 스택 영역

- 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역임
- Stack은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸함
- 원시타입의 데이터가 값과 함께 할당됨
- Heap 영역에 생성된 Object 타입의 데이터 참조값이 할당됨
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됨
- 컴파일 타임에 크기가 결정되기 때문에 무한히 할당 할 수 없음, 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생함

<details>
<summary> Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?</summary>
할당/해제 속도는 Stack 이 빠르다.

>💡 스택에서 할당의 의미는 이미 생성되어 있는 스택에 대해 포인터의 위치만 바꿔주는 단순한 CPU Instruction(덧셈과 뺄셈 연산, 일반적으로 단일 Instruction)이다. 반면 힙에서의 할당은 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등 다양한 요소를 고려하기 때문에 더 많은 CPU Instruction이 필요하다.

접근 속도는 할당/해제 속도를 빼놓고 이야기할 수 없다고 한다.
</details>

 ## JVM 메모리 구조

![8uh8SPy](https://user-images.githubusercontent.com/33995823/189523556-430b0ed5-a66a-400e-987c-97b98bbe956f.png)

### Metaspace 영역

- 자바8 이후로 추가된 영역
 	- 자바7 이전까지는 힙 영역 안의 Permanent Generation 영역에 속했었다.
 	- Metaspace 영역은 Native Memory 에 위치한다.
 	- 힙 영역은 JVM이 관리하지만 Metaspace 영역은 OS가 관리한다.
- 자바 클래스 로더가 클래스 definition 등의 메타 정보를 저장한다.

### Code Cache 영역

- 코드의 수행 빈도와 복잡도 등을 고려하여 JVM이 바로 실행할 수 있는 기계어 코드 일부를 런타임 이전에 미리 컴파일 하여 캐싱 하고있는 영역이다.

> cf) 자바 컴파일 과정  
>
> 1. 자바 컴파일러가 소스코드 (.java 파일) 를 바이트코드 (.class 파일) 로 변환  
> 2. JIT (Just In Time) 컴파일러가 런타임에 바이트코드를 기계어로 변환

- 캐시 크기는 아주 작기 때문에 컴파일된 기계어 코드 전체를 저장할 수는 없다.

### Shared Libraries 영역

- 네이티브 코드로 작성된 라이브러리가 저장되는 영역이다.
- 네이티브 코드란 자바가 아닌 다른 언어 (C, C++) 로 작성된 코드를 말한다.
  - 대표적으로 Object 클래스의 hashCode() 메소드
- 주로 퍼포먼스 이슈 또는 이미 다른 언어로 구현된 라이브러리를 자바로 포팅하는것을 피하기 위한 용도로 사용된다.

### Thread Stack 영역

- 일반적인 쓰레드 영역과 동일하다.

### Heap 영역

- 효율적인 힙 메모리 관리를 위해 Young 영역과 Old 영역으로 나뉜다. (세대별 구분)

  **Young Generation 영역**
  - 새로운 객체 또는 생긴지 오래되지 않은 객체가 저장되는 영역이다.
  - 가비지 컬렉션중 Minor GC가 수행되는 영역이다.
  - Eden 영역과 Survivor space 영역으로 나뉜다.
	> Eden: 새로 객체가 생성되는 영역  
	> Survivor: Minor GC가 일어나 살아남은 객체들이 저장되는 영역. 매 GC마다 살아남은 객체들은 S0과 S1에 번갈아가며  저장된다.  

  **Old Generation 영역**
  - Minor GC를 여러 번 겪으면서도 계속 살아있는 객체들이 저장되는 영역이다.
  - 가비지 컬렉션중 Major GC가 수행되는 영역이다.

## 프로세스 간 통신 (IPC)

## IPC란?

**Inter Process Communication**의 약자로 프로세스들끼리 서로 데이터를 주고 받는 행위 또는 그에 대한 방법을 말함.

![img](https://raw.githubusercontent.com/KUkingClass/cs-class/main/Operating%20System/IPC/imgs/1.png)

위 그림처럼 **프로세스는 완전히 독립된 실행체**입니다. 서로 독립되어 있다는 것은 **다른 프로세스의 영향을 받지 않는다**는 장점이 있습니다. 하지만 독립되어 있는 만큼 **별도의 설비가 없이는 서로간에 통신이 어렵다**는 문제가 있게 된다.

이를 위해서 커널 영역에서 IPC라는 내부 프로세스간 통신을 제공하게 되고, 프로세스는 커널이 제공하는 IPC설비를 이용해서 프로세스간 통신을 할 수 있게 됨.

### IPC의 종류

1. 메시지 전달 (Message Passing)
    - 커널이 제공하는 API를 이용해서 커널 공간을 통해 통신한다. 
    - 메시지 큐(Mesage Queue)를 사용하여 송신 프로세스는 큐에 enqueue, 수신 프로세스는 큐에 dequeue 하며 상호간 통신한다. 
    - 메시지 큐는 커널 단에서 관리된다.
    > 파이프 (쉘에서 사용하는 그 파이프임)
    소켓 (TCP/IP) - 로컬에서도 통신이 가능하며 원격에서도 통신이 가능하다. (IP : 127.0.0.1일 경우 로컬에서 패킷을 통해 프로세스끼리 통신하기도 한다.)
2. 메모리 공유 (Shared Memory)
   - 프로세스끼리 특정 공통의 메모리 영역을 공유하며 상호간 통신하는 방법이다.
   - 데이터 자체를 공유하도록 지원하며, 한 프로세스에서 변경한 메모리 공간의 내용을 다른 프로세스에서 접근할 수 있다. 공유 메모리는 커널에서 관리된다.

### 다양한 IPC들

1) PIPE (익명 PIPE)
   - 파이프는 두 개의 프로세스를 연결하게 되고, 하나의 프로세스는 데이터를 쓰기만, 다른 하나는 데이터를 읽기만 할 수 있습니다.
   - 통신을 할 프로세스가 명확하게 알 수 있는 경우 사용합니다.
   - 전이중 통신을 하려면 2개를 만들어야한다.
2) Named PIPE(FIFO)
   - Named PIPE는 전혀 모르는 상태의 프로세스들 사이의 통신의 경우 사용합니다.
   - PIPE는 같은 부모의 PPID를 가진 프로세스 안에서만 통신 가능하지만 FIFO은 아니다.
   - 읽기/쓰기가 동시에 가능하지 않다.
   - 전이중 통신을 하려면 2개를 만들어야한다.
3) Message Queue
   - 입출력 방식은 Named 파이프와 동일함
   - Name PIPE가 데이터의 흐름이라면 메시지 큐는 메모리 공간이다.
   - 메시지 큐에 쓸 데이터에 번호를 붙임으로써 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.
4) Shared Memory(공유 메모리)
   - 파이프, 메시지 큐가 통신을 이용한 설비라면, 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비다.
   - 프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근하지 못하도록 반드시 보호되야한다. 하지만 다른 프로세스가 데이터를 사용하도록 해야하는 상황도 필요할 것이다. 파이프를 이용해 통신을 통해 데이터 전달도 가능하지만, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다.
   - 공유 메모리는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용해준다.
   - 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다.
   >중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동함
5) Memory Map(메모리 맵)
   - 공유 메모리처럼 메모리를 공유해준다. 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식이다. (즉 공유 매개체가 파일+메모리)
   - 주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.
6) Socket(소켓)
   - 네트워크 소켓 통신을 통해 데이터를 공유한다.
   - 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
   - 서버(bind, listen, accept), 클라이언트(connect)

이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)

> 출처
> https://velog.io/@gang_shik/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84
