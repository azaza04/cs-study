# [Operating System] CPU 스케줄링

> 운영체제에서 여러 프로세스가 동시에 실행될 때, 각 프로세스가 CPU와 같은 제한된 자원을 효율적으로 관리하는 것은 매우 중요하다. 운영체제는 **적절한 스케줄링 알고리즘**을 사용하여, 프로세스들이 언제 어떤 순서로 CPU를 사용할지 결정한다. 적절한 스케줄링 알고리즘을 사용하면 **시스템 응답성이 개선**되고, **대기 시간이 최소화**되며, **전체 시스템 성능이 최적화**된다. 즉, CPU 이용률을 최대화 하며 성능을 높이는 것은 다중 프로세서 운영체제 설계의 핵심이 된다.

### 🙋‍♀️ 목차
- [CPU 스케줄링](#cpu-스케줄링)
  - [프로세스 생명주기](#프로세스-생명주기)
  - [디스패처와 스케줄러](#디스패처와-스케줄러)
- [스케줄링 알고리즘](#스케줄링-알고리즘)
  - [스케줄링 알고리즘 평가 기준](#스케줄링-알고리즘-평가-기준)
  - [스케줄링 알고리즘 목표](#스케줄링-알고리즘-목표)
  - [스케줄링 알고리즘 종류](#스케줄링-알고리즘-종류)
  - [멀티스레드 환경에서의 스케줄링](#멀티스레드-환경에서의-스케줄링)
  - [실제 운영체제에서 사용하는 스케줄링 알고리즘](#실제-운영체제에서-사용하는-스케줄링-알고리즘)
- [부록](#부록)
  - [자바 스레드 풀과 스케줄링 알고리즘의 상관관계](#자바-스레드-풀과-스케줄링-알고리즘의-상관관계)
  - [비동기 작업 스케줄링과 CPU 활용 최적화](#비동기-작업-스케줄링과-CPU-활용-최적화)
- [질문](#질문)
- [출처](#출처)

<br/>

## 프로세스 생명주기

![image](https://github.com/user-attachments/assets/71086e36-6072-450f-bd65-9ff19db8286c)

- **New(생성)** 상태에서 시작하여, CPU에 의해 실행될 준비가 되면 **Ready(준비)** 상태로 전환
- CPU가 프로세스를 선택하여 실행하면 **Running(실행)** 상태가 되며, 입출력 작업이나 다른 대기 작업이 필요하면 **Waiting(대기)** 상태로 이동
- 작업이 모두 완료되면 **Terminated(종료)** 상태가 되며 프로세스의 생명주기가 끝남

<br/>

## 디스패처와 스케줄러

이 생명주기 동안 프로세스가 CPU를 사용할 수 있도록 돕는 것이 스케줄러의 역할

- **단기 스케줄러** = 실행 가능한 프로세스들 중에서 어느 것을 실행할지 결정
- **디스패처** = 스케줄러의 결정을 받아 CPU에 실제로 할당

스케줄러는 프로세스의 상태 변화에 최적의 결정을 내려야 하며(스케줄링 알고리즘), 디스패처는 이 결정이 빠르고 효율적으로 이행되도록 보장해야 한다.

<br/>

# 스케줄링 알고리즘

## 스케줄링 알고리즘 평가 기준

스케줄링 알고리즘이 얼마나 효과적인지 평가하기 위한 몇 가지 지표

- **Turnaround Time**
    - 프로세스가 생성된 후부터 완료될 때까지의 전체 시간
    - 프로세스가 얼마나 빨리 완료되는지를 나타내며, Turnaround Time이 짧을수록 시스템의 처리 효율이 높아짐
- **Response Time**
    - 프로세스가 생성된 후 처음으로 CPU를 사용하기까지 걸리는 시간
    - 시스템이 사용자 명령에 얼마나 빠르게 반응하는지 평가하는 기준(특히 인터랙티브 시스템에서 중요)
    - Response Time이 짧을수록 사용자는 시스템이 신속하게 반응한다고 느낄 수 있음

<br/>

## 스케줄링 알고리즘 목표

- 높은 CPU 활용도 - 가능한 CPU를 바쁘게 유지하기
- 높은 공정성 - CPU 할당은 공정해야 함
- 높은 처리량 - 처리량은 최대여야 함, 즉 단위 시간당 실행을 완료하는 프로세스 수가 최대가 되어야 함
- 최소 대기 시간이 있어야 하며, 프로세스가 준비 대기열에서 Starvation 되면 안됨
- 최소 처리 시간
- 최소 응답 시간

<br/>

## 스케줄링 알고리즘 종류

스케줄링 알고리즘은 크게 **비선점(Nonpreemptive)** 방식과 **선점(Preemptive)** 방식으로 나눌 수 있음

![image 1](https://github.com/user-attachments/assets/57206be4-84b2-4e00-b300-0c521a0255ab)

<br/>

### 비선점(Nonpreemptive) 방식

- **FCFS(First-Come, First-Served)**
    - 프로세스가 도착한 순서대로 처리하는 가장 기본적인 방식
    - 구현이 단순하지만, 긴 프로세스가 먼저 도착하면 다른 프로세스들이 오래 대기해야 하는 **Convoy Effect**가 발생할 수 있음

<br/>

- **SJF(Shortest Job First)**
    - 프로세스의 실행 시간이 가장 짧은 것부터 처리하는 방식
    - 비선점 방식이므로, 프로세스가 일단 실행되고 나면, 수행시간이 상대적으로 더 짧은 프로세스가 들어와도 중간에 실행이 넘어가지 않음 ⇒ **즉, SJF 방식 또한 Convoy 효과를 막을 순 없음**
    - 이 방식은 Turnaround Time을 최소화하는 데 효과적이지만, 실행 시간이 긴 프로세스가 무한정 대기하게 되는 문제가 발생할 수 있음
    - 모든 운영체제 스케줄링 알고리즘 중 평균 대기 시간이 최소

<br/>

### 선점(Preemptive) 방식

- **STCF(Shortest Time to Completion First)**
    - 남은 실행 시간이 가장 짧은 프로세스를 **우선** 처리하는 방식
    - SJF의 선점형 버전 ⇒ Convoy 문제 해결
    - 이 방식은 Turnaround Time을 줄이지만, 빈번한 문맥 전환으로 인해 시스템 오버헤드가 증가할 수 있음

<br/>

- **RR(Round Robin)**
    - 모든 프로세스에 일정한 시간(Time Slice)을 할당하여 순환하는 방식
    - 공정성을 보장하지만, Time Slice의 크기에 따라 성능이 달라짐
    - Time Slice가 짧으면 컨텍스트 스위칭 오버헤드가 증가하고, 길면 응답 시간이 길어지는 trade-off
    - Response Time이 아주 짧은 반면 Turnaround Time은 좋지 못함

<br/>

- **MLFQ(Multi-Level Feedback Queue)**
    - **여러 개의 큐**를 사용하여 프로세스의 우선순위를 동적으로 조정하는 방식
    - **각 큐가 각자의 우선순위**를 가지고 있음, 같은 큐 내에서도 각 프로세스/스레드의 우선순위에 따라 진행
        - 각 프로세스/스레드의 우선순위가 같다면 RR 스케줄링을 따름
    - 우선순위는 어떻게 할당하는데?
        - I/O bound, CPU bound 작업으로 분류 + aging
        - 계속해서 I/O 요청을 하며 CPU를 양보한다면 우선순위를 높게 유지 + 주어진 time slice를 모두 사용하면 우선순위를 낮춤
    - 상위 큐에서는 짧은 Time Slice를, 하위 큐에서는 긴 Time Slice를 할당하여, 다양한 작업 유형에 유연하게 대응할 수 있음
    - **생길 수 있는 문제점**
        - Starvation
            - I/O bound job이 많으면 우선순위에 밀려 CPU bound job이 실생 순서를 받지 못하는 문제 발생
        - Changing behavior
            - job이 시간이 흐름에 따라 I/O bound <-> CPU bound 로 변할 수 있음

<br/>

## **멀티스레드 환경에서의 스케줄링**

멀티스레드 환경에서는 스레드 간의 자원 경합을 최소화하는 것이 중요함

스레드마다 독립적으로 스케줄링되거나, 스레드 그룹 단위로 스케줄링되어 CPU 사용을 최적화

### **커널 수준 스케줄링**

- **커널이 직접 관리하는 스레드 스케줄링**으로, 운영체제가 각 스레드에 대해 독립적으로 스케줄링 결정을 내림
- 이 방식에서는 운영체제가 각 CPU 코어에 스레드를 할당하며, 멀티코어 시스템에서의 효율적인 스레드 배분이 가능해짐
- **장점**: 스레드가 독립적으로 스케줄링되므로, 다중 CPU에서 병렬 처리가 효과적이며, 시스템 전체의 자원 관리가 중앙에서 통제됨
- **단점**: 커널의 스케줄러가 직접 개입하기 때문에 컨텍스트 스위칭 오버헤드가 증가할 수 있음

### **사용자 수준 스케줄링**

- 사용자 수준의 라이브러리에서 스레드를 스케줄링하는 방식으로, 여기서 스레드 관리는 **운영체제가 아닌 프로세스 내부의 라이브러리**가 담당함
- 이 방식에서는 스레드의 컨텍스트 스위칭이 사용자 공간에서 발생하므로, 커널 호출이 없기 때문에 **빠른 전환**이 가능함
- **장점**: 커널의 개입 없이 사용자 공간에서 빠르게 스레드를 전환할 수 있어, 오버헤드가 적고 성능이 향상될 수 있음
- **단점**: 하나의 스레드가 블로킹 I/O 작업에 걸리면, 동일 프로세스 내의 다른 모든 스레드도 함께 블로킹될 수 있음

### **혼합형 스케줄링**

- 커널 수준과 사용자 수준 스케줄링의 장점을 결합한 방식
- 사용자 수준에서 많은 스레드를 관리하고, 그중 일부만 커널 수준에서 관리되는 스레드로 매핑하여 운영
- **장점**: 시스템 자원의 효율적 사용과 함께 사용자 공간에서의 빠른 스레드 전환을 동시에 달성할 수 있음
- **단점**: 구현이 복잡하며, 두 가지 스케줄링 계층 간의 조정이 필요함

<br/>

## 실제 운영체제에서 사용하는 스케줄링 알고리즘

실제 운영체제에서는 각 운영체제의 특성과 목적에 맞게 다양한 스케줄링 알고리즘이 사용됨

### 리눅스(Linux)

- **Completely Fair Scheduler (CFS)**
    - 리눅스 커널에서 기본적으로 사용되는 스케줄러
    - CFS는 각 프로세스에 "가상 런타임"을 할당하여 공정성을 보장, 이 알고리즘은 프로세스가 사용한 CPU 시간을 기반으로 스케줄링 우선순위를 결정하며, 프로세스들이 공평하게 CPU 시간을 배분받도록 설계됨
- **Deadline Scheduler**
    - 실시간 작업을 위한 스케줄러로, 프로세스의 데드라인을 기반으로 작업의 우선순위를 결정함

### 윈도우(Windows)

- **윈도우 NT 스케줄러**
    - Windows NT 기반 운영체제에서는 **Multilevel Feedback Queue (MLFQ)** 알고리즘을 변형한 형태가 사용됨
    - 우선순위 기반의 선점형 스케줄링을 사용하며, 프로세스의 우선순위에 따라 큐에서 위치가 변동될 수 있고, 사용자 입력이나 I/O 대기 등의 작업에 민감한 프로세스는 높은 우선순위를 부여받아 더 자주 실행됨

### **macOS**

- **Multilevel Feedback Queue (MLFQ)**
    - macOS는 Multilevel Feedback Queue 스케줄러를 기반으로 하여 우선순위 기반의 선점형 스케줄링을 사용함
    - 실시간 태스크를 위한 실시간 우선순위 스케줄링도 제공함

### **유닉스 (Unix)**

- **기본 Unix 스케줄러**
    - 전통적인 유닉스 시스템에서는 **Round Robin**과 **MLFQ**를 결합한 스케줄링을 사용함
    - 우선순위 기반 스케줄링으로, 프로세스의 우선순위는 시간에 따라 변하며, 시스템에 따라 다양한 변형이 존재

### **안드로이드 (Android)**

- **CFS (Completely Fair Scheduler)**
    - 안드로이드는 리눅스 커널을 기반으로 하기 때문에, CFS를 기본 스케줄러로 사용
    - **Android's Power Management**에 특화된 조정을 통해 모바일 환경에서의 전력 효율성을 높이고 있음

### **iOS**

- **Multilevel Feedback Queue (MLFQ)**
    - iOS는 macOS와 비슷하게 MLFQ 기반 스케줄러를 사용
    - 모바일 기기의 특성상, 배터리 효율성과 사용자 경험을 최적화하기 위해 우선순위가 실시간으로 조정될 수 있음

⇒ 대부분 MLFQ, CFS를 사용하는 것을 알 수 있음!

<br/>

# 부록

## 자바 스레드 풀과 스케줄링 알고리즘의 상관관계

- **스레드 풀(Thread Pool)의 개념**:
    
    자바 스레드 풀은 미리 생성된 스레드 집합을 사용하여 작업을 처리함으로써 스레드 생성 비용을 절감하고, 시스템의 스레드 수를 효율적으로 관리할 수 있는 도구임. 이를 통해 애플리케이션 성능을 최적화하고, 리소스 사용을 제어할 수 있음.
    
- **스레드 풀의 종류**:
    - **Fixed Thread Pool**:
        
        정해진 수의 스레드를 유지하는 스레드 풀로, CPU 바운드 작업에 적합함. 스케줄링 알고리즘은 주어진 스레드 내에서 작업을 균등하게 분배하는 방식으로 설계됨.
        
    - **Cached Thread Pool**:
        
        작업이 들어올 때마다 새로운 스레드를 생성하되, 이전에 사용된 스레드를 재사용하는 스레드 풀로, 주로 I/O 바운드 작업에 유리하며 CPU 자원을 효율적으로 사용하도록 스케줄링됨.
        
- **스케줄링 전략**:
    
    스레드 풀 내부에서 사용되는 작업 큐에 **FIFO(First In, First Out)**, **LIFO(Last In, First Out)** 또는 **우선순위 큐**를 적용하여 스케줄링할 수 있음. 이러한 전략은 서버의 응답성과 자원 사용률에 큰 영향을 미치며, 적절한 전략을 선택함으로써 시스템의 성능을 최적화할 수 있음.
    
<br/>

## 비동기 작업 스케줄링과 CPU 활용 최적화

- **비동기 프로그래밍의 필요성**:
    
    서버 애플리케이션에서 비동기 작업은 CPU와 I/O 작업을 병렬로 처리하여 성능을 극대화하는 데 필수적임. 비동기 프로그래밍을 통해 시스템이 블로킹 없이 효율적으로 동작하며, 높은 트래픽 상황에서도 응답성을 유지할 수 있음.
    
- **자바에서의 비동기 프로그래밍**:
    - **@Async 어노테이션**
        - 자바 스프링에서 비동기 작업을 선언적으로 처리하는 방법임. 이 어노테이션을 사용하면 메서드가 별도의 스레드에서 비동기적으로 실행되며, 메인 스레드의 성능에 영향을 주지 않음.
    - **CompletableFuture**
        - 비동기 작업의 결과를 비동기적으로 처리할 수 있는 API로, 복잡한 비동기 작업의 체이닝을 통해 효율적으로 작업을 관리할 수 있음. 이를 통해 여러 비동기 작업을 동시에 실행하고 결과를 처리할 수 있음.
- **스케줄링 전략**:
    
    비동기 작업에서 스레드 풀을 어떻게 관리하고, 작업의 우선순위나 순서를 어떻게 설정할지에 대한 전략을 논의함. CPU를 최적으로 활용하기 위해 **Time Slice**를 조정하거나 작업의 **Prioritization**을 통해 자원 할당을 최적화할 수 있음.
    
- **예시**:
    
    비동기 메서드를 사용해 여러 I/O 바운드 작업을 동시에 처리하고, 이로 인해 응답 속도가 어떻게 개선되는지 실제 코드를 통해 시연함. 이를 통해 비동기 프로그래밍과 적절한 스케줄링 전략이 서버 성능에 미치는 긍정적인 영향을 보여줌.
    

<br/>

# 질문

<details>
    <summary>싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케줄링 알고리즘을 사용하는 것이 좋을까요?</summary>
    <ul>
        <li>싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스를 효율적으로 관리하기 위해서는 <strong>Round Robin (RR)</strong> 또는 <strong>MLFQ (Multi-Level Feedback Queue)</strong>와 같은 선점형 스케줄링 알고리즘이 적합합니다.</li>
        <li>RR은 일정한 시간(Time Slice)을 주기적으로 모든 프로세스에 할당하기 때문에, 상시로 돌아가야 하는 프로세스가 CPU 시간을 꾸준히 얻을 수 있습니다.</li>
        <li>MLFQ도 상시로 돌아가야 하는 프로세스를 우선순위가 높은 큐에 위치시켜 주기적으로 CPU를 할당할 수 있어 효과적입니다.</li>
    </ul>
</details>

<details>
    <summary>타 스케줄러와 비교하여, MLFQ는 어떤 문제점들을 해결할 수 있나요?</summary>
    <ul>
        <li><strong>다양한 작업 유형에 대한 유연성</strong>: MLFQ는 여러 개의 큐를 사용해 프로세스의 우선순위를 동적으로 조정합니다. 이는 다양한 작업 유형(예: CPU 집중적, 입출력 집중적)에 대해 각각 적절한 우선순위를 부여해 성능을 최적화할 수 있습니다.</li>
        <li><strong>Starvation 방지</strong>: MLFQ는 오래 대기하는 프로세스를 하위 큐에서 상위 큐로 승격시키는 방식으로 Starvation 문제를 완화할 수 있습니다. 이는 낮은 우선순위 프로세스가 무한정 대기하는 상황을 방지합니다.</li>
        <li><strong>인터랙티브 응답성</strong>: 상위 큐에는 짧은 Time Slice를 할당해, 사용자 인터랙션이 많은 프로세스가 신속하게 응답할 수 있도록 합니다.</li>
    </ul>
</details>

<details>
    <summary>FIFO 스케줄러는 별로인가요? 꼭 사용해야 하는 경우가 있진 않을까요?</summary>
    <ul>
        <li>예를 들어, <strong>실시간 시스템</strong>에서 작업이 순차적으로 처리되어야 하고, 작업의 순서가 중요한 경우 FIFO 스케줄러가 적합할 수 있습니다.</li>
        <li>프로세스 간의 우선순위가 같고, 공평성이 중요한 경우에도 FIFO 스케줄러를 사용하는 것이 타당할 수 있습니다.</li>
        <li>그러나 FIFO 스케줄러는 Convoy Effect를 유발할 수 있기 때문에 주의가 필요합니다.</li>
    </ul>
</details>

<details>
    <summary>프로세스 스케줄링과 스레드 스케줄링은 어떻게 다른가요?</summary>
    <ul>
        <li><strong>프로세스 스케줄링</strong>: 독립적인 프로세스 간의 CPU 할당을 관리합니다. 각 프로세스는 자체적인 메모리 공간을 가지며, 프로세스 간의 문맥 전환은 상대적으로 무겁고 오버헤드가 큽니다.</li>
        <li><strong>스레드 스케줄링</strong>: 하나의 프로세스 내에서 다수의 스레드 간의 CPU 할당을 관리합니다. 스레드는 동일한 메모리 공간을 공유하므로, 스레드 간의 문맥 전환이 비교적 가볍고 빠릅니다.</li>
        <li>멀티스레드 환경에서는 스레드 스케줄링이 프로세스 스케줄링보다 더 자주 일어나며, 시스템의 응답성과 효율성을 높일 수 있습니다.</li>
    </ul>
</details>

<details>
    <summary>유저 스레드와 커널 스레드의 스케줄링 알고리즘은 똑같을까요?</summary>
    <ul>
        <li><strong>유저 스레드</strong>: 유저 스레드는 커널이 아닌 사용자 레벨에서 관리되기 때문에, 커널은 유저 스레드에 대해 직접적으로 스케줄링하지 않습니다.</li>
        <li>유저 레벨의 스레드 라이브러리가 자체적인 스케줄링 알고리즘을 구현하여 유저 스레드를 관리합니다. 이 스케줄링은 커널 스레드와는 독립적으로 동작합니다.</li>
        <li><strong>커널 스레드</strong>: 커널 스레드는 커널에 의해 직접 스케줄링되며, 운영체제의 스케줄러가 이를 관리합니다. 커널 스레드는 프로세스와 마찬가지로 운영체제의 전반적인 스케줄링 알고리즘(CFS, RR 등)에 따라 관리됩니다.</li>
    </ul>
</details>

<details>
    <summary>멀티코어 프로세서에서 각 코어에 프로세스를 어떻게 효율적으로 분배할 수 있을까요?</summary>
    <ul>
        <li>멀티코어 프로세서에서 각 코어에 프로세스를 효율적으로 분배하기 위해서는 <strong>Load Balancing</strong>과 <strong>CPU Affinity</strong>를 고려한 스케줄링 알고리즘이 필요합니다.</li>
        <li><strong>Load Balancing</strong>은 모든 코어가 균등하게 작업을 분배받도록 하고, <strong>CPU Affinity</strong>는 프로세스가 한 코어에 계속 실행되도록 하여 캐시 효율성을 높입니다.</li>
        <li>이러한 접근법은 코어 간 작업 불균형과 문맥 전환 오버헤드를 줄일 수 있습니다.</li>
    </ul>
</details>

<details>
    <summary>스케줄링 알고리즘의 공정성을 평가하는 기준은 무엇이며, 특정 스케줄링 알고리즘에서 어떻게 공정성을 보장할 수 있을까요?</summary>
    <ul>
        <li>공정성은 프로세스 간 CPU 사용의 균등성을 의미합니다. 이를 평가하기 위해 <strong>Wait Time</strong>, <strong>Response Time</strong> 등을 고려합니다.</li>
        <li><strong>Completely Fair Scheduler (CFS)</strong>는 공정성을 보장하려는 대표적인 알고리즘으로, 프로세스의 실행 시간을 균등하게 분배하여 공정성을 유지합니다.</li>
    </ul>
</details>

<details>
    <summary>모바일 장치나 배터리로 구동되는 시스템에서는 에너지 효율성이 중요합니다. CPU가 쉬지 못하면 에너지 효율성이 떨어질 것 같은데요, 어떤 스케줄링 알고리즘이 에너지 효율성을 높일 수 있으며, 이를 위해 어떤 전략을 사용할 수 있을까요?</summary>
    <ul>
        <li>에너지 효율성을 높이기 위해서는 <strong>Dynamic Voltage and Frequency Scaling (DVFS)</strong>를 활용한 스케줄링이 중요합니다.</li>
        <li><strong>Tickless Kernel</strong>과 같은 접근법은 CPU의 유휴 시간을 최대화하여 전력 소비를 줄일 수 있습니다.</li>
        <li>또한, 에너지-aware 스케줄링 알고리즘은 작업 부하에 따라 CPU 성능을 동적으로 조정합니다.</li>
    </ul>
</details>

<details>
    <summary>컨텍스트 스위칭 비용을 줄이기 위해 스케줄링 알고리즘에서 고려해야 할 사항들은 무엇인가요?</summary>
    <ul>
        <li><strong>Thread Pooling</strong>과 같은 방법을 사용해 문맥 전환 빈도를 낮추고, 프로세스와 스레드를 효율적으로 관리하는 것이 중요합니다.</li>
        <li><strong>Cooperative Scheduling</strong>은 프로세스 간의 자발적 양보를 통해 문맥 전환을 최소화할 수 있습니다.</li>
    </ul>
</details>

<details>
    <summary>가상화 환경에서는 여러 가상 머신이 하나의 물리적 CPU를 공유합니다. 이런 환경에서 효과적인 스케줄링 전략은 무엇이며, 가상화로 인한 스케줄링 문제를 어떻게 해결할 수 있을까요?</summary>
    <ul>
        <li>가상화 환경에서는 <strong>CPU 리소스 공유</strong>와 <strong>Isolation</strong>이 중요한 문제입니다.</li>
        <li><strong>Credit Scheduler</strong>와 같은 알고리즘은 각 가상 머신에 CPU 시간을 공정하게 할당하며, <strong>Overcommitting</strong>을 관리합니다.</li>
        <li>가상화 환경에서는 또한 호스트와 게스트 OS 간의 협력이 중요하며, <strong>Hypervisor</strong>에서 이를 관리합니다.</li>
    </ul>
</details>

<br/>

# 출처

- [https://github.com/devSquad-study/2023-CS-Study/blob/main/OS/os_cpu_scheduling_and_algorithm.md](https://github.com/devSquad-study/2023-CS-Study/blob/main/OS/os_cpu_scheduling_and_algorithm.md)
- [https://velog.io/@youjung/프로세스-스케줄링-9xcm3lp1#스케줄링-시-고려-사항](https://velog.io/@youjung/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-9xcm3lp1#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%8B%9C-%EA%B3%A0%EB%A0%A4-%EC%82%AC%ED%95%AD)
- [https://github.com/VSFe/Tech-Interview/blob/main/02-OPERATING_SYSTEM.md](https://github.com/VSFe/Tech-Interview/blob/main/02-OPERATING_SYSTEM.md)
- [https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html](https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html)
