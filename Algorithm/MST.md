# MST 알고리즘

## Spanning Tree란?

그래프 내의 모든 정점을 포함하는 트리

- Spanning Tree = 신장 트리
- Spanning Tree는 그래프의 최소 연결 부분 그래프 이다.
- - 최소 연결 = 간선의 수가 가장 적다.
- - n개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 바로 Spanning Tree가 된다.
- 즉, 그래프에서 일부 간선을 선택해서 만든 트리

## Spanning Tree의 주요 특징

- 그래프의 모든 정점 포함: 스패닝 트리는 주어진 그래프의 모든 정점을 포함합니다.
- 사이클이 없음: 트리의 특성상, 스패닝 트리에는 사이클이 존재하지 않습니다.
- 간선의 개수: 스패닝 트리는 항상 n-1개의 간선을 가집니다. 여기서 n은 정점의 개수입니다.
- 연결된 그래프: 스패닝 트리는 연결된 그래프에서만 만들 수 있습니다. 그래프가 연결되지 않았다면 스패닝 트리를 만들 수 없습니다.

## MST란?

최소 스패닝 트리 (Minimum Spanning Tree)
스패닝 트리 중에서도 가중치가 있는 그래프에서는 모든 간선에 가중치가 부여되며, 이때 스패닝 트리 중에서 가중치의 합이 최소가 되는 트리를 최소 스패닝 트리라고 합니다.

## MST의 특성

가중치의 합이 최소: 주어진 그래프에서 가능한 스패닝 트리 중에서 가중치의 합이 최소가 되는 트리입니다.
여러 개의 최소 스패닝 트리: 가중치가 같은 간선이 있는 경우, 하나 이상의 최소 스패닝 트리가 존재할 수 있습니다.

## MST의 대표적인 알고리즘 두가지

### Kruskal 알고리즘

#### 동작 과정

1. 모든 간선 정렬
   주어진 그래프의 모든 간선을 가중치 순으로 오름차순 정렬합니다.
2. 초기화
   각 정점이 자신만의 트리(또는 집합)를 형성하게 설정합니다. (보통 유니온 파인드(Union-Find) 자료구조를 사용)
3. 간선 선택

- 가장 작은 가중치를 가진 간선부터 차례로 선택합니다.
- 선택한 간선이 사이클을 만들지 않으면 그 간선을 트리에 추가합니다.
- 트리 내의 간선의 개수가 n-1개(정점의 개수가 n이라면) 될 때까지 이 과정을 반복합니다.

4. 사이클 방지
두 정점을 연결하는 간선을 추가할 때, 두 정점이 이미 같은 집합에 속해 있는지 확인합니다. 만약 같은 집합에 속해 있다면 사이클이 형성되므로 그 간선은 추가하지 않습니다.
![kruskal](https://github.com/user-attachments/assets/1bcb5eb3-6e51-4dfd-8ae3-3d630b15ef46)

#### 구현 과정
1. 간선 목록을 가중치 순으로 정렬합니다.
2. 유니온 파인드 자료구조를 초기화합니다.
3. 가중치가 작은 간선부터 차례대로 탐색합니다.
- 해당 간선의 두 정점이 서로 다른 집합에 속해 있다면, 간선을 선택하고 두 집합을 하나로 병합합니다.
- 이미 같은 집합에 속해 있으면 해당 간선을 건너뜁니다.
4. 트리에 포함된 간선의 수가 n-1개가 되면 알고리즘을 종료하고 최소 스패닝 트리를 반환합니다.


#### 사이클 생성 여부를 확인하는 방법
추가하고자 하는 간선의 양끝 정점이 같은 집합에 속해 있는지를 먼저 검사해야 한다.
‘union-find 알고리즘’ 이용

> 유니온 파인드(Union-Find)
사이클이 형성되는 것을 막기 위해 유니온 파인드(또는 Disjoint Set Union, DSU) 자료구조를 사용합니다.
> - Find: 특정 노드가 속한 집합의 대표(root)를 찾는 작업.
> - Union: 두 집합을 하나로 합치는 작업.
> - 경로 압축(Path Compression): Find 연산 중, 같은 집합에 속한 노드들을 트리의 루트에 바로 연결해 경로를 압축하는 최적화 방법.
> - 랭크 기반 합치기(Union by Rank): Union 연산에서 트리의 높이가 더 낮은 트리를 더 높은 트리 밑에 붙여 트리의 깊이를 최소화하는 최적화 방법.

#### Kruskal 알고리즘의 시간 복잡도
- 간선을 가중치 순으로 정렬하는 데 O(E log E)의 시간이 소요됩니다. (E는 간선의 개수)
- 유니온 파인드 자료구조를 사용하는 과정에서 각 Union-Find 연산은 거의 상수 시간(아커만 함수의 역함수인 매우 느린 성장을 보임)이 걸립니다.
- 따라서 크루스칼 알고리즘의 시간 복잡도는 O(E log E)입니다.
  
#### Kruskal 알고리즘의 장단점
장점
- 그래프가 **희소 그래프(간선이 적은 그래프)** 일 때 매우 효율적입니다.
- 간선이 미리 정렬되어 있는 경우 매우 빠르게 작동합니다.
단점
- 그래프가 **밀집 그래프(간선이 많은 그래프)** 인 경우 Prim 알고리즘보다 비효율적일 수 있습니다.
- 간선 정렬에 시간이 많이 걸릴 수 있습니다.

### Prim 알고리즘

#### 동작 과정

1. **임의의 시작 정점 선택**: 그래프에서 아무 정점이나 선택해 시작합니다.
2. **최소 가중치 간선 선택**: 현재 트리에 포함된 정점들과 인접한 간선 중에서 가중치가 가장 작은 간선을 선택합니다.
3. **정점 추가**: 선택한 간선에 연결된 정점을 트리에 추가합니다.
4. **반복**: 모든 정점이 트리에 포함될 때까지 2~3 과정을 반복합니다.

#### 주요 개념

1. **우선순위 큐 사용**: 인접한 간선 중에서 가장 작은 가중치를 효율적으로 찾기 위해 **우선순위 큐**(보통 **최소 힙**)를 사용합니다.
2. **트리 확장**: 간선을 추가하면서 점차적으로 트리가 확장됩니다. 매번 가장 작은 가중치의 간선을 선택하는 그리디 방식으로 동작합니다.
3. **방문 처리**: 이미 트리에 포함된 정점으로부터 새로운 정점을 방문 처리하면서 트리를 확장해 나갑니다.
   
![prim](https://github.com/user-attachments/assets/0433f3d7-4c0e-47c3-9842-758395152018)

#### 구현 과정

1. **임의의 시작 정점**을 선택합니다.
2. **우선순위 큐**에 시작 정점과 인접한 간선들을 넣습니다.
3. **큐에서 최소 가중치의 간선**을 꺼내, 그 간선이 연결하는 정점이 트리에 포함되지 않았다면 트리에 추가합니다.
4. **방문한 정점과 인접한 간선**을 큐에 추가합니다.
5. 모든 정점이 트리에 포함될 때까지 이 과정을 반복합니다.

#### Prim 알고리즘의 시간 복잡도

프림 알고리즘은 우선순위 큐를 사용하여 최소 간선을 효율적으로 선택합니다.

- **우선순위 큐를 사용**하는 경우: `O(E log V)`  
  (E는 간선의 개수, V는 정점의 개수)
- 우선순위 큐에 간선을 삽입하고 최소 값을 추출하는 과정이 `log V` 시간에 이루어집니다.

### Prim 알고리즘의 장단점

장점
- **밀집 그래프(간선이 많은 그래프)** 에서 크루스칼 알고리즘보다 더 효율적입니다.
- 시작 정점을 자유롭게 선택할 수 있으며, **트리 확장 방식**이 직관적입니다.

단점
- 그래프가 **희소 그래프(간선이 적은 그래프)** 일 경우 간선을 하나씩 선택하는 방식 때문에 크루스칼 알고리즘보다 비효율적일 수 있습니다.


## 최소 스패닝 트리의 활용

- **네트워크 설계**: 통신망, 전력망, 도로망 등에서 최소한의 비용으로 모든 노드를 연결하는 문제.
- **클러스터링**: 데이터 분석에서 최소 스패닝 트리를 사용하여 군집화(클러스터링) 문제를 해결할 수 있습니다.
- **회로 설계**: 전자 회로에서 와이어의 길이를 최소화하는 데 사용됩니다.

스패닝 트리는 그래프에서 기본적인 개념이지만, 이를 기반으로 최적화 문제를 해결하는 데 매우 유용합니다.
