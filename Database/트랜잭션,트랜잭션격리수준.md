# 트랜잭션 (Transaction)

> 데이터베이스 내에서 수행되는 여러 작업을 하나의 논리적 작업 단위로 묶은 것

비즈니스 로직을 수행할 때 **모든 작업이 성공적으로 완료되거나, 실패했을 경우 모든 작업이 취소되는 것을 보장**

트랜잭션은 일련의 데이터베이스 작업을 **원자적**(Atomic)으로 처리함으로써 데이터의 일관성을 유지하고, 장애나 오류가 발생했을 때 데이터가 일관성을 잃지 않도록 보호함

<br/>

### 롤백과 커밋

- **커밋(Commit)**
  - 트랜잭션 내의 모든 연산이 성공적으로 수행된 후, 이를 데이터베이스에 영구적으로 반영하는 작업
  - 커밋 후에는 더 이상 트랜잭션의 변경 사항을 되돌릴 수 없음. 즉, 커밋은 트랜잭션의 성공을 확정하는 단계
- **롤백(Rollback)**
  - 트랜잭션이 실패했을 때, 해당 트랜잭션에서 수행된 모든 연산을 취소하고 데이터베이스를 트랜잭션이 시작되기 전 상태로 되돌리는 작업
  - 롤백은 트랜잭션의 일관성을 보장하기 위한 핵심 기법임.
- **AutoCommit**:
  - MySQL과 같은 많은 DBMS에서는 기본적으로 `AutoCommit` 기능이 활성화되어 있어, 각 쿼리 실행 후 자동으로 커밋됨. 이를 비활성화하고 명시적으로 커밋 또는 롤백을 호출할 수 있음

<br/>

### 일반적인 트랜잭션 사용 패턴

1. **트랜잭션 시작**: 트랜잭션의 시작 시점에서는 보통 데이터베이스 연결을 통해 트랜잭션을 시작한다. 스프링에서는 `@Transactional` annotation을 통해 자동으로 트랜잭션이 시작된다.
2. **비즈니스 로직 수행**: 트랜잭션 내에서 비즈니스 로직을 수행하면서 여러 데이터베이스 작업을 처리한다. 이 때 발생하는 모든 쿼리는 트랜잭션의 일관성을 유지한다.
3. **커밋**: 모든 작업이 성공적으로 완료되었을 때 트랜잭션을 커밋하여 데이터베이스에 반영한다.
4. **롤백**: 오류나 예외가 발생할 경우, 트랜잭션을 롤백하여 데이터베이스 상태를 원래대로 되돌린다.

<br/>

### 트랜잭션의 원칙 ACID

트랜잭션이 데이터의 일관성을 보장하는 이유는 ACID 원칙을 따르기 때문이다.

- **Atomicity (원자성)**: All or Nothing
  - 트랜잭션 내의 작업은 모두 수행되거나, 전혀 수행되지 않아야 함.
  - 예를 들어, 은행 송금에서 돈이 한 계좌에서 빠져나갔지만 다른 계좌로 들어가지 않는 상황은 발생해서는 안됨.
  - 수행중인 트랜잭션에 의해 변경된 내역은 유지하면서 이전 상태는 임시영역에 따로 저장, 오류가 발생하는 경우 임시영역에 저장되어있는 이전 상태를 롤백하여 원자성을 보장한다.
    - `롤백 세그먼트`: 임시로 저장되는 영역.
    - `데이터베이스 테이블`: 현재 트랜잭션에 의해 새롭게 변경되는 내역.
- **Consistency (일관성)**
  - 트랜잭션이 시작되기 전과 완료된 후의 데이터베이스 상태는 일관되어야 함.
  - 데이터베이스의 무결성 제약 조건을 위반하는 트랜잭션은 커밋되지 않고 롤백됨.
  - 예를 들어, 외래 키 제약이나 고유 제약 등이 위반될 경우 트랜잭션은 롤백됨.
- **Isolation (고립성)**
  - 동시에 실행되는 트랜잭션이 서로 간섭하지 않도록 해야 함.
  - 여러 트랜잭션이 동시에 수행될 때, 고립성이 보장되지 않으면 하나의 트랜잭션에서 처리 중인 데이터를 다른 트랜잭션에서 읽거나 수정할 수 있어 데이터의 무결성이 훼손될 수 있음.
- **Durability (지속성)**
  - 트랜잭션이 커밋된 후에는 시스템에 장애가 발생하더라도 그 상태가 유지되어야 함.
  - 이는 데이터베이스가 트랜잭션 로그를 사용하여 보장하며, 장애 발생 시에도 로그를 바탕으로 트랜잭션을 복구할 수 있음.

<br/>

# 트랜잭션 격리 수준 (Isolation Levels)

- 격리수준(isolation level)이란 트랜잭션끼리 **얼마나 서로 고립되어 있는지를 나타내는 수준**
- 즉, 한 트랜잭션이 **다른 트랜잭션이 변경한 데이터**에 대한 접근 강도를 의미한다.
- 레벨이 높아질수록 트랜잭션간 고립정도가 높아지며, 성능저하도 야기한다.
- 일반적인 온라인 서비스에서는 `READ COMMITTED`나 `REPEATABLE READ` 중 하나를 사용

<br/>

## Isolation 관련 발생할 수 있는 문제점

> 격리성을 완전히 보장하기 위해 모든 트랜잭션을 순차적으로 실행한다면 동시성 처리 이슈가 발생합니다.
> 반대로 동시성을 높이기 위해 여러 트랜잭션을 병렬처리하게 되면 데이터의 무결성이 깨질 수 있습니다.

### 1. Dirty Read

> 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것

아래의 이미지를 보면 Transaction_1이 정상처리되지 않고, Rollback 될 수 있는데, 이럴 경우 그 값을 이미 읽은 Transaction_2는 잘못된 값을 가지고 본인의 로직을 처리하는 상태에 놓이게 된다.

![image](https://github.com/user-attachments/assets/8e501312-1448-47ce-979f-50fb3ad67fe8)

<br/>

### 2. Non-Repeatable Read

> 한 트랜잭션 내에서 같은 Key를 가진 Row를 두 번 읽었는데 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 현상

![image 1](https://github.com/user-attachments/assets/bec9ac6b-f762-4f7c-83e3-f8a70b138834)

<br/>

### 3. Phantom Read

> 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상

![image 2](https://github.com/user-attachments/assets/1455c339-8dfc-47f0-a10d-6f8354f40700)

※ Phantom Read와 Non-Repeatable Read와의 차이점은 Non-Repeatable Read는 1개의 Row의 데이터의 값이 변경되는 것이며 Phantom Read는 여러 건을 요청하는 것에 대해서 데이터의 값이 변동되는 것이다.

위 격리성 이슈들로 인해 ANSI 표준에서는 트랜잭션의 격리성과 동시 처리 성능 사이의 Trade-off를 두고 4단계로 격리 수준을 나눴다. 격리수준을 높힐수록 이슈들은 적게 발생하지만 동시 처리 성능은 떨어진다.

<br/>

## 트랜잭션 격리 수준

### 1. **READ UNCOMMITTED**

![image 3](https://github.com/user-attachments/assets/06893d07-5876-4402-a98d-bb26671e0b3c)

⇒ 트랜잭션이 아직 **커밋되지 않은 데이터**를 다른 트랜잭션에서 읽을 수 있음.

즉, 트랜잭션이 완료되지 않은 상태에서 수행된 변경 사항도 다른 트랜잭션에 노출될 수 있음.

이 격리 수준에서는 모든 트랜잭션 격리성 문제(Dirty Read, Non-Repeatable Read, Phantom Read)가 발생할 수 있음. 하지만 동시 처리 성능이 매우 높기 때문에, **읽기 성능**을 극대화해야 하는 상황에서 사용될 수 있음.

- **발생 가능 이슈**:
  - **Dirty Read**: 커밋되지 않은 트랜잭션의 데이터를 다른 트랜잭션에서 읽음으로써, 해당 트랜잭션이 롤백되면 무효한 데이터를 읽게 되는 문제.
  - **Non-Repeatable Read**: 한 트랜잭션에서 같은 데이터를 반복 조회할 때, 그 사이에 다른 트랜잭션이 데이터를 변경하여 결과가 달라지는 문제.
  - **Phantom Read**: 한 트랜잭션 내에서 같은 쿼리를 반복 실행할 때, 다른 트랜잭션에서 새로운 데이터를 삽입하거나 삭제하여 결과 집합이 달라지는 문제.
- **사용 예시**: 실시간 분석 시스템, 로그 데이터 처리, 데이터 일관성보다 속도가 중요한 비정형 데이터 처리 상황. **정확한 데이터보다는 빠른 접근이 중요한 경우**에 주로 사용됨.

<br/>

### 2. **READ COMMITTED**

![image 4](https://github.com/user-attachments/assets/6015dd71-3d0f-4b92-9121-bb8407d2bbb7)

⇒ **커밋된 데이터만 읽을 수 있는 수준**. 즉, 트랜잭션이 커밋되기 전의 데이터는 다른 트랜잭션에서 읽을 수 없음.

Dirty Read 문제는 해결되었지만, **Non-Repeatable Read**와 **Phantom Read** 문제는 여전히 발생할 수 있음.

이 격리 수준은 실무에서 가장 흔하게 사용되는 격리 수준 중 하나로, 특히 **데이터 일관성**과 **동시성**의 균형을 맞추는 데 적합함. 많은 데이터베이스에서 기본 설정으로 사용됨.

- **발생 가능 이슈**:
  - **Non-Repeatable Read**: 트랜잭션 내에서 동일한 데이터를 두 번 이상 읽을 때, 다른 트랜잭션에서 데이터가 수정되어 첫 번째 읽은 값과 두 번째 읽은 값이 달라지는 문제.
  - **Phantom Read**: 동일한 조건으로 쿼리를 실행했을 때, 트랜잭션 중간에 다른 트랜잭션이 데이터를 삽입하여 처음 쿼리할 때와 나중에 쿼리할 때 결과 집합이 달라지는 문제.
- **사용 예시**: 일반적인 **웹 애플리케이션**, **온라인 쇼핑몰**, **게시판 시스템** 등에서 많이 사용됨. **동시성**이 중요하면서도 어느 정도의 **데이터 일관성**을 보장해야 하는 환경에서 적합함.

<br/>

### 3. **REPEATABLE READ**

![image 5](https://github.com/user-attachments/assets/78351404-87e8-4351-b9f0-2c45dda31ea2)

⇒ 트랜잭션 내에서 **같은 데이터를 반복해서 조회해도 항상 동일한 값**을 반환함.

이 격리 수준에서는 **Dirty Read**와 **Non-Repeatable Read** 문제를 해결하지만, **Phantom Read** 문제는 여전히 발생할 수 있음.

MySQL의 InnoDB 엔진에서는 기본적으로 **REPEATABLE READ**를 사용하며, 이를 통해 트랜잭션이 일관된 상태에서 여러 번의 읽기 작업을 수행할 수 있음.

- **발생 가능 이슈**:
  - **Phantom Read**: 트랜잭션 도중에 다른 트랜잭션이 데이터를 삽입하거나 삭제하여, 동일한 쿼리를 실행했을 때 처음 조회 결과와 나중 조회 결과가 달라지는 문제.
- **사용 예시**: **은행 거래 시스템**, **주식 거래 시스템** 등 **데이터의 일관성**이 매우 중요한 경우. 특히 여러 단계의 읽기 및 검증 작업이 요구되며, 트랜잭션 내에서 데이터가 변동되지 않아야 하는 상황에서 주로 사용됨.

<br/>

### 4. **SERIALIZABLE**

⇒ 가장 높은 수준의 트랜잭션 격리 수준으로, **트랜잭션을 순차적으로 실행하여** 다른 트랜잭션과의 간섭을 완전히 차단함.

이 격리 수준에서는 모든 트랜잭션이 **직렬화**되어 마치 하나씩 차례대로 실행되는 것처럼 처리됨.

모든 트랜잭션 격리 문제(Dirty Read, Non-Repeatable Read, Phantom Read)가 해결되며, 가장 높은 수준의 데이터 일관성을 보장하지만 **성능이 크게 저하**될 수 있음. 동시에 실행 가능한 트랜잭션의 수가 줄어들어 병목 현상이 발생할 수 있음.

- **발생 가능 이슈**: 없음. **모든 트랜잭션 격리 문제**가 해결됨.
- **사용 예시**: **항공권 예약 시스템**, **중요한 금융 거래 시스템** 등에서 **절대적인 데이터 무결성**이 보장되어야 하는 경우 사용됨. 데이터의 변동이 중요한 비즈니스 논리에 큰 영향을 미치는 경우, 트랜잭션을 순차적으로 처리하여 오류를 방지해야 할 때 사용됨.

![image 6](https://github.com/user-attachments/assets/6ebd90c1-2dc4-4f46-827c-0e3151613fec)

<br/>

### 실무에서의 트랜잭션 격리 수준 선택

실제 환경에서는 트랜잭션 격리 수준을 선택할 때 **성능과 데이터 일관성의 균형**을 고려해야 한다. 트랜잭션이 자주 발생하고 동시성이 중요한 시스템에서는 성능을 중시해 낮은 격리 수준을 사용할 수 있으며, 데이터 무결성이 매우 중요한 금융 시스템이나 예약 시스템 등에서는 높은 격리 수준을 적용해야 한다.

- **READ UNCOMMITTED**: 실시간 분석, 로그 시스템 등 데이터 일관성이 덜 중요한 경우
- **READ COMMITTED**: 대부분의 웹 애플리케이션에서 사용. 특히 상품 조회, 게시판 목록 조회 등 비즈니스 로직에서 안전하고 성능을 적절히 보장할 수 있는 수준
- **REPEATABLE READ**: 금융 거래 시스템, 은행 계좌 조회 등 데이터 일관성이 매우 중요한 시스템에서 주로 사용
- **SERIALIZABLE**: 항공권 예약, 주요 금융 거래 등 데이터 일관성이 절대적으로 중요한 경우

<br/>

### 격리 수준 선택 시 고려 사항:

1. **애플리케이션의 특성**: 읽기 중심인지, 쓰기 중심인지에 따라 선택할 격리 수준이 달라질 수 있다.
2. **동시성 요구**: 높은 동시성 처리 성능을 요구하는 시스템은 낮은 격리 수준이 필요할 수 있다.
3. **데이터 일관성의 중요도**: 금융, 의료, 예약 시스템 등에서 높은 일관성이 요구되며, 이 경우 높은 격리 수준을 선택해야 한다.
4. **성능 요구**: 트랜잭션 처리 속도와 성능을 고려하여 적절한 타협점을 찾아야 한다.

<br/>

# 출처

https://youtu.be/taUeIi6a6hk?si=xhBa8H5OKsnd4ukt

https://youtu.be/sLJ8ypeHGlM?si=1CnMqhWmD6Qwo7P6

https://youtu.be/bLLarZTrebU?si=Yg3iCzar1v_tcBg4

https://akasai.space/db/about_isolation/
