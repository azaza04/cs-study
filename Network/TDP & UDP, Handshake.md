# TDP & UDP, Handshake

## TCP(Transmission Control Protocol)

> TCP는 연결 지향적 프로토콜이다.
※ 연결 지향적 프로토콜은  클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜을 의미한다.

- 장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정해 신뢰성을 보장하는 연결형 서비스이다.
- TCP는 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟(데이터, 메시지, 세그먼트라는 블록 단위)을 안정적으로, 순서대로, 에러 없이 교환할 수 있게 한다.

### TCP 특징

1. 연결형 서비스로 가상 회선 방식을 제공
3-way handshaking 과정을 통해 연결을 설정하고,
4-way handshaking 과정을 통해 연결을 해제한다.
2. 흐름 제어(Flow control)
데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지
3. 혼잡 제어(Congestion control)
네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지
4. 높은 신뢰성을 보장
신뢰성이 높은 전송을 하기 때문에 UDP보다 속도가 느림
5. 전이중(Full-Duplex), 점대점(Point to Point) 방식
전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.

---
(1). 가상 회선 방식을 제공한다는 것은 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다는 말이다. 3-way handshaking 과정은 발신지와 수신지 사이에 논리적인 접속(세션)을 성립하는 과정을 의미한다. TCP가 위와 같은 특징을 지니는 이유는 간단하다. TCP는 연결형 서비스로, 신뢰성을 보장하기 때문이다.
그래서 3-way handshaking의 과정도 사용하는 것이고, 
(2). 데이터의 흐름 제어나 
(3). 혼잡 제어와 같은 기능도 하는 것이다.
(4). 하지만 이러한 기능 때문에 UDP보다 속도가 느리게 된다.
그렇기에 TCP는 연속성보다 신뢰성 있는 전송이 중요할 때 사용하는 프로토콜로 예를 들면, 파일 전송과 같은 경우에 사용된다.

---

## UDP(User Datagram Protocol)

> UDP는 TCP와 달리 연결이 없는 프로토콜로, 데이터를 빠르게 전송하지만 신뢰성이나 순서 보장은 하지 않는다.
> UDP는 TCP와 비교해봤을 때 훨씬 간단한 헤더 구조를 갖는다. 출발지, 목적지, 체크섬과 같이 데이터 전송에 필수적인 부분만 있고, 다른 필드는 존재하지 않는다. 이는 UDP에는 TCP처럼 복잡한 규칙이 적용되지 않기 때문이다. 이는 데이터의 안정적인 송수신을 보장하지는 않겠다는 뜻이기도 하다.
>
### UDP 특징

1. 비연결형 서비스로 데이터그램 방식을 제공한다.
데이터의 전송 순서가 바뀔 수 있다.
2. 데이터 수신 여부를 확인하지 않는다.
TCP의 3-way handshaking과 같은 과정 X
3. 신뢰성이 낮다.
흐름 제어(flow control)가 없어서 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
4. TCP보다 속도가 빠르다.
5. 1:1 & 1:N & N:N 통신이 가능하다.

## TCP 연결(3-way) & 해제(4-way) handshake

SYN(synchronize sequence numbers) - 연결 확인을 보내는 무작위의 숫자 값 (내 말 들려?)ACK(acknowledgements) - Client 혹은 Server로부터 받은 SYN에 1을 더해 SYN을 잘 받았다는 ACK (잘 들려!)

### TCP 연결 3way

1. 먼저 Open 한 클라이언트가 SYN(내 말 들려?)를 보내고 SYN_SENT 상태로 대기한다.
2. 서버는 SYN-RECEIVED 상태로 바꾸고 SYN과 응답 ACK(어 잘 들려! 내 말은 들려?)를 보낸다.
3. SYN과 응답 ACK를 받은 클라이언트는 ESTABLISHED 상태로 변경하고 서버에게 응답 ACK(잘 들려!)를 보낸다.
4. 응답 ACK를 받은 서버는 ESTABLISHED 상태로 변경한다.
출처: https://dev-coco.tistory.com/144 [슬기로운 개발생활:티스토리]

### TCP 해제 4way

1. 먼저 close를 실행한 클라이언트가 FIN(연결 끊자!)을 보내고 FIN-WAIT-1 상태로 대기한다.
2. 서버는 CLOSE-WAIT으로 바꾸고 응답 ACK(알겠어! 잠시만~)를 전달한다. 동시에 해당 포트에 연결되어 있는 애플리케이션에게 close를 요청한다.
3. ACK를 받은 클라이언트는 상태를 FIN-WAIT-2로 변경한다.
4. close 요청을 받은 서버 애플리케이션은 종료 프로세스를 진행하고 FIN(나도 끊을게!)을 클라이언트로 보내 LAST_ACK 상태로 바꾼다.
5. FIN을 받은 클라이언트는 ACK(알겠어!)를 서버에 다시 전송하고 TIME-WAIT으로 상태를 바꾼다.
TIME-WAIT에서 일정 시간이 지나면 CLOSE 된다. ACK를 받은 서버도 포트를 CLOSED로 닫는다.

## 질문


<details>
<summary>TCP의 3-way handshake 과정은 무엇인가요?</summary>

- **SYN**: 클라이언트가 서버에 연결을 요청하는 패킷을 보냅니다.
- **SYN-ACK**: 서버는 요청을 수신하고, 클라이언트의 요청을 수락한다는 신호로 응답을 보냅니다.
- **ACK**: 클라이언트는 서버의 응답을 수락하고, 이를 확인하는 패킷을 보냅니다.
- 이 과정을 통해 클라이언트와 서버 간에 신뢰할 수 있는 연결이 설정됩니다.

</details>

<details>
<summary>TCP의 4-way handshake 종료 과정은 무엇인가요?</summary>

- **FIN**: 클라이언트가 서버에 연결을 종료하려고 요청하는 패킷을 보냅니다.
- **ACK**: 서버는 클라이언트의 FIN 패킷을 수락하고, 확인 응답을 보냅니다.
- **FIN**: 서버도 연결 종료를 요청하는 FIN 패킷을 클라이언트에게 보냅니다.
- **ACK**: 클라이언트는 서버의 FIN 패킷을 수락하고, 마지막으로 ACK 응답을 보냅니다.
- 이 과정을 통해 TCP 연결이 안전하게 종료됩니다.

</details>

<details>
<summary>UDP를 사용하는 애플리케이션의 예를 들어 보세요.</summary>

- **실시간 스트리밍**: 비디오 또는 오디오 스트리밍은 약간의 데이터 손실보다 지연이 적은 것이 더 중요합니다.
- **VoIP (Voice over IP)**: 음성 통화 중 약간의 패킷 손실은 통화 품질에 큰 영향을 미치지 않으며, 지연을 최소화하는 것이 중요합니다.
- **온라인 게임**: 빠른 반응이 중요한 FPS 게임이나 스포츠 게임에서는 UDP를 사용하여 지연 시간을 줄입니다.
- **DNS 쿼리**: 짧고 빠른 요청 응답이 필요하며, 패킷 손실 시 재요청을 보내는 것이 더 효율적입니다.

</details>

<details>
<summary>TCP와 UDP 중 하나를 선택해야 한다면, 언제 어떤 것을 사용하시겠습니까?</summary>

- **TCP를 사용할 때**:
  - 데이터의 신뢰성과 무결성이 중요한 경우.
  - 데이터가 순서대로 전송되어야 하는 경우.
  - 예: 파일 전송, 이메일, 웹 브라우징.

- **UDP를 사용할 때**:
  - 빠른 전송 속도가 필요하고, 약간의 데이터 손실이 허용되는 경우.
  - 네트워크 지연이 적어야 하는 실시간 애플리케이션.
  - 예: 비디오 스트리밍, 온라인 게임, VoIP.

</details>

<details>
<summary>UDP가 신뢰성이 떨어진다고 하는데, 이 문제를 어떻게 해결할 수 있을까요?</summary>

- **애플리케이션 레벨에서 신뢰성 추가**: UDP를 사용하는 애플리케이션이 자체적으로 오류 검출과 재전송 메커니즘을 구현할 수 있습니다.
- **FEC (Forward Error Correction)**: 패킷 손실 시 데이터 복구를 위한 추가적인 정보(오류 수정 코드)를 전송합니다.
- **패킷 순서 번호**: 각 패킷에 순서 번호를 부여하여 수신자가 패킷의 순서를 재구성할 수 있도록 합니다.
- **ACK/NAK 메커니즘**: 송신자는 수신자로부터 수신 확인(ACK)을 받아 패킷 전송 성공을 확인하고, 실패 시 재전송을 수행합니다.

</details>

<details>
<summary>TCP에서 "헤드 오브 라인 블로킹(Head-of-Line Blocking)"이란 무엇인가요?</summary>

- **헤드 오브 라인 블로킹**은 네트워크에서 앞쪽의 패킷이 지연되거나 손실될 때 뒤쪽의 패킷도 함께 지연되는 현상입니다.
- TCP는 순서 보장을 위해 순차적으로 패킷을 처리하므로, 앞의 패킷이 도착하지 않으면 뒤의 패킷이 도착해도 처리할 수 없습니다.
- 이 문제는 HTTP/2와 HTTP/3의 멀티플렉싱 및 독립적 스트림 처리로 해결되었습니다.

</details>

<details>
<summary>Handshake 과정이 실패할 수 있는 이유는 무엇인가요?</summary>

- 네트워크 연결 문제: 클라이언트와 서버 간에 네트워크 연결이 불안정하거나 차단된 경우.
- 방화벽 또는 보안 설정: 특정 포트나 프로토콜에 대한 접근이 제한된 경우.
- 서버 부하: 서버가 과부하 상태여서 새로운 연결 요청을 처리할 수 없는 경우.
- 잘못된 구성: 클라이언트 또는 서버가 올바르게 설정되지 않은 경우 (예: SSL/TLS 설정 문제).
- 시간 초과: 요청과 응답 사이의 지연이 너무 길어서 연결이 타임아웃되는 경우.

</details>

---

> 출처: https://dev-coco.tistory.com/144 [슬기로운 개발생활:티스토리]