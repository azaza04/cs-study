## TCP 통신

-   **정의**: 네트워크 통신에서 신뢰적인 연결방식 = reliable network를 보장하는 프로토콜
-   **How?**: network congestion avoidance 알고리즘을 사용

## reliable Network

### unreliable vs reliable

-   **unreliable**: 전송한 데이터그램이 유실될 수 있고, 순서가 바뀌어 도착할 수 있음
-   **reliable**: 세그먼트가 유실될 경우 재전송을 통해 복구, 순서가 바뀌어 도착하더라고 순서 번호를 이용하여 제대로 맞추어 전달

### reliable network의 4가지 문제점

reliable network를 보장한다는 것은 4가지 문제점 존재

-   손실 : packet이 손실될 수 있는 문제
-   순서 바뀜 : packet의 순서가 바뀌는 문제
-   Congestion : 네트워크가 혼잡한 문제
-   Overload : receiver가 overload 되는 문제

-> 보통 TCP  전송 제어 방법은 전송되는 데이터 양을 조정하는 흐름제어, 통신 도중 손실되거나 잘못된 데이터가 수신되었을때 대처하는 오류 제어, 네트워크 혼잡에 대처하는 혼잡 제어로 존재

### 흐름제어

-   **정의**: 전송되는 데이터 양을 조정하는 기법
-   **Why?**: 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위해
    -   수신측 처리 속도가 더 빠른 경우 -> 문제x
    -   수신측 처리 속도가 느린 경우 -> 수신 측의 버퍼가 가득차버리는 문제 발생 -> 용량을 초과한 이후에 도착하는 패킷은 손실 가능성 존재
-   **How?**: 수신측이 송신측에게 자신의 상태를 feedback 진행
    -   Stop and Wait: 매번 전송한 패킷에 대해 확인 응답(ACK)을 받아야만 그 다음 패킷을 전송하는 방법
        -   패킷을 하나씩 보내기에 비효율적 방법

![image](https://github.com/user-attachments/assets/9a6f3064-c4c4-44ba-85c0-66f30e61c50a)

-    
    -   Sliding Window: 수신 측이 한 번에 처리할 수 있는 데이터(window)를 정해놓고, 수신 측의 데이터 처리 상황을 송신 측에 알려줘서, 상황에 따라 window의 크기를 제어하는 방법
        -   초기 윈도우 크기는 호스트 간의 3 Way Handshaking 과정에서 수신 측이 결정
        -   수신 측이 확인 응답(ACK)을 보낼 때 TCP 헤더에 담아서 전송 
        -   대부분 해당 방식을 사용

![image](https://github.com/user-attachments/assets/32000572-bb1a-44a1-80d3-e402b9e52927)

### 혼잡 제어

-   **정의**: 네트워크 혼잡에 대처하는 기법
-   **Why?**: 
    -   송신측의 데이터가 라우터를 거쳐 수신측으로 전달
    -   이때, 한 라우터에서 데이터가 몰리는 경우, 자신에게 온 데이터를 모두 처리 불가
    -   송신측은 이런 경우 손실 데이터로 간주하고 계속 데이터를 재전송 -> 네트워크 혼잡 발생
-   **How?**: 송신 측에서 보내는 데이터의 전송 속도를 강제로 줄이자!
    -    AIMD( Additive Increase / Multiplicative Decrease ): 합 증가/ 곱 감소 방식 = 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜 전송. 만약 전송이 실패하면 윈도우의 크기를 반으로 줄이는 방식
        -   문제점: 윈도우의 크기를 조금씩 늘리기에, 네트워크 모든 대역을 활용하기까지 오래 걸린다. ( 처음 전송 속도를 높이는데 오래 걸림 )

![image](https://github.com/user-attachments/assets/3f7f0975-5d6b-48b4-bf0a-ad41764bd9ca)

-   -   Slow Start (느린 시작): 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 2배씩 증가시켜 전송. 만약 전송이 실패하면 윈도우의 크기를 1로 줄이는 방식
    -   Fast Retransmit (빠른 재전송):
        -   패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
        -   단, 순서대로 잘 도착한 **마지막 패킷의 다음 패킷의 순번**을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
        -   중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.

![image](https://github.com/user-attachments/assets/ad18cc2e-7fa3-4b77-9a5f-23f223366f02)

-   -   Fast Recovery (빠른 회복): 
        -   혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법
        -   이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

![image](https://github.com/user-attachments/assets/8291fa35-3c8d-4bc9-a0d3-e5f80ba1f4a2)