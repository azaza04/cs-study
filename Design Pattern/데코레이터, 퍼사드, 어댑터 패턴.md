## 구조 패턴

-   클래스나 객체를 조합해 더 큰 구조를 만드는 패턴

### 데코레이터 패턴

-   **정의**: 객체의 결합을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴
-   **목적**: 기존 클래스에 여러 추가 기능들을 조합해서 확장을 해야할 때 사용

#### 배경

-   SW를 개발할 때, 객체에 새로운 기능을 추가해야 할 경우가 자주 발생
-   이때, 상속을 사용해 클래스를 확장하는 방식이 일반적이지만, 상속은 클래스가 많아질수록 코드가 복잡해지고 유지보수가 어려움
-   특히, **각 기능을 조합**할 때마다 새로운 클래스를 만들어야 하는 비효율성이 발생

![image](https://github.com/user-attachments/assets/2665ee20-bc4e-4f07-ae3b-8bef3edb54fb)

| ![image](https://github.com/user-attachments/assets/69865cdf-9ca5-4886-9e30-51703b0030a7)    | ![image](https://github.com/user-attachments/assets/3ff87bdd-6d98-40c4-916b-308e60c29187) |
| --- | --- |

#### 해결

-   상속 대신 객체를 동적으로 감싸 추가 기능을 더하는 방식으로 진행하자!
-   즉, 필요한 기능만을 추가하고 조합할 수 있어 코드의 중복을 줄이고 관리가 용이

![image](https://github.com/user-attachments/assets/8ee8f164-9e68-46bb-9a3a-5b031993bf7b)

| ![image](https://github.com/user-attachments/assets/1e21fc6c-2756-4bb1-a6e8-0fd947cf84fc) | ![image](https://github.com/user-attachments/assets/4b3d5793-0401-48ae-bbad-7bf6ab8e93f0) |
| --- | --- |

### 퍼사드 패턴

-   **정의**: 복잡한 서브 클래스들의 공통적인 기능을 정의하는 상위 수준의 인터페이스를 제공하는 패턴
-   **목적**: 복잡한 시스템의 내부 동작을 숨기고, 단순한 인터페이스를 제공해 사용자가 쉽게 기능을 사용할 수 있도록 돕기 위해

#### 배경

세탁을 하기 위해서는 크게 Washing, Rinsing, Spinning과 같은 동작들이 필요

![image](https://github.com/user-attachments/assets/6bc30d91-e017-404f-9772-1d81a4e99d93)

| ![image](https://github.com/user-attachments/assets/d3df72c7-807c-4adf-a5f0-8c7ad6fd41d6) | ![image](https://github.com/user-attachments/assets/2e5999cb-9c93-4a26-8c88-74fb864570b1) |
| --- | --- |

\> 클라이언트가 여러 객체들에 결합되어, 유지보수에 용이하지 않음

#### 해결

Washing, Rinsing, Spinning과 같은 동작들을,  Facade Object를 통해 **'**세탁'이라는 행위에 필요한 공통 기능으로 정의

![image](https://github.com/user-attachments/assets/7daafb93-ed3d-4bb1-8008-a7613a660af0)

| ![image](https://github.com/user-attachments/assets/b513beee-d77d-4652-95ca-cbf22df2c7af) | ![image](https://github.com/user-attachments/assets/432bb9d3-838f-4c23-a671-c4f7e8c5e9af) |
| --- | --- |

\> 이렇게 하면 클라이언트는 서브 시스템들의 코드를 몰라도, Facade Object만 알면 사용이 가능 + 서브 시스템들간의 복잡한 결합도 또한 낮출 수 있다.

### 어댑터 패턴

-   **정의**: 서로 호환되지 않는 인터페이스를 가진 클래스들이 함께 동작할 수 있도록 중간에 변환기를 제공하는 패턴
-   **목적**: 기존 코드를 수정하지 않고도 다른 인터페이스와 호환되도록 하기 위해

#### 배경

-   기존 코드에서 사용 중인 클래스와 새로 도입하려는 클래스의 인터페이스가 달라서 직접 사용하기 어려움
-   이를 해결하기 위해서는 기존 코드를 수정해야 하는데, 이는 유지보수나 확장성에 좋지 않음

| ![image](https://github.com/user-attachments/assets/5f24265b-315a-4147-a2fe-8330141afc84) | ![image](https://github.com/user-attachments/assets/b70679a0-3169-4691-a8e3-dd2b1c4279ee) |
| --- | --- |

#### 해결

-   기존 클래스와 새 클래스를 연결하는 어댑터를 만들어, 수정 없이 두 클래스가 함께 작동할 수 있게 하자!

| ![image](https://github.com/user-attachments/assets/f9e77796-b684-4fa3-b02f-f50b5783c44c) | ![image](https://github.com/user-attachments/assets/8bc29db3-81d1-4746-b853-76bce8b42c90) |
| --- | --- |